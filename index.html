<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GDROM v2 Narrative Visualization</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    .graticule {
      stroke-dasharray: 2,2;
      stroke: #ccc;
      fill: none;
    }
    #container {
      max-width: 1000px;
      margin: auto;
      padding: 20px;
      font-family: sans-serif;
    }
    button {
      margin-top: 20px;
      padding: 5px 10px;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Meet the Reservoirs: A Look into Each Data Category</h1>
    <div id="scene"></div>
    <button id="nextButton">Next Scene</button>
  </div>

  <script>
    let sceneIndex = 0;

    const scenes = [
      drawScene1,
      drawScene2,
      drawScene3,
      drawScene4
    ];

    function clearScene() {
      d3.select("#scene").html("");
    }

    function drawScene1() {
      clearScene();

      d3.select("#scene")
        .append("h2")
        .text("Scene 1: The U.S. Reservoir Data Gap");

      d3.select("#scene")
        .append("p")
        .html(`
          <strong>Reservoirs are essential to water management</strong>, providing services such as:
          <ul>
            <li>Water supply</li>
            <li>Flood control</li>
            <li>Hydropower generation</li>
            <li>Recreation and navigation</li>
          </ul>
          However, reservoir operations also <em>significantly alter natural streamflow regimes</em>, making them a key source of human influence on hydrological systems.<br><br>

          Despite extensive research, realistic analysis of reservoir behavior remains challenging due to <strong>limited data availability</strong>.<br><br>

          To address this gap, we developed the <strong>GDROM v2 dataset</strong>, which reconstructs daily inflow, release, and storage records for <strong>2,017 reservoirs across the contiguous U.S.</strong>, using a <em>data fusion approach</em> that combines:
          <ul>
            <li>USGS streamflow measurements</li>
            <li>Remote-sensing-based surface area observations</li>
            <li>Bathymetric profiles</li>
          </ul>
          Each reservoir is categorized by the length of its historical records:
          <ul>
            <li><strong>Data-Rich (Res-R)</strong>: &gt; 5 years</li>
            <li><strong>Data-Limited (Res-L)</strong>: 1–5 years</li>
            <li><strong>Data-Missing (Res-M)</strong>: &lt; 1 year</li>
          </ul>
          <br>
          <em>Please cite as:</em><br>
          Zheng, Z., X. Cai, Y. Chen (2025). <i>GDROM v2: An Inventory of Operation Variables and Rules for 2,017 Large Reservoirs across the CONUS</i>, HydroShare. <a href="http://www.hydroshare.org/resource/5293674cb83b4ec698db0eb4777467b8" target="_blank">http://www.hydroshare.org/resource/5293674cb83b4ec698db0eb4777467b8</a>
        `);


      const width = 960, height = 600;
      const svg = d3.select("#scene")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const projection = d3.geoAlbersUsa().scale(1300).translate([width / 2, height / 2]);
      const path = d3.geoPath().projection(projection);

      Promise.all([
        d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json"),
        d3.csv("reservoir_metadata.csv")
      ]).then(([us, data]) => {
        const colorScale = d3.scaleOrdinal()
          .domain(["Res_R", "Res_L", "Res_M"])
          .range(["#1f77b4", "#ff7f0e", "#999999"]);  // blue, orange, gray

        // Graticule for lat/lon grid
        const graticule = d3.geoGraticule();

        svg.append("path")
          .datum(graticule())
          .attr("class", "graticule")
          .attr("d", path);

        // Draw U.S. state boundaries
        svg.append("g")
          .selectAll("path")
          .data(topojson.feature(us, us.objects.states).features)
          .join("path")
          .attr("fill", "none")
          .attr("stroke", "#666")
          .attr("stroke-width", 0.7)
          .attr("d", path);

        // Draw reservoir points
        svg.append("g")
          .selectAll("circle")
          .data(data.filter(d => d.LONGITUDE && d.LATITUDE))
          .join("circle")
          .attr("cx", d => projection([+d.LONGITUDE, +d.LATITUDE])[0])
          .attr("cy", d => projection([+d.LONGITUDE, +d.LATITUDE])[1])
          .attr("r", 2.5)
          .attr("fill", d => colorScale(d.CATEGORY))
          .attr("opacity", 0.8)
          .append("title")
          .text(d => `${d.RES_NAME || d.DAM_NAME || "Unknown"} (${d.CATEGORY})`);

        // Draw legend
        const legend = svg.append("g")
          .attr("transform", `translate(${width - 165}, ${height - 165})`);

        const categories = ["Res_R", "Res_L", "Res_M"];
        const labels = {
          "Res_R": "Data-Rich (>5 years)",
          "Res_L": "Data-Limited (1–5 years)",
          "Res_M": "Data-Missing (<1 year)"
        };

        legend.selectAll("rect")
          .data(categories)
          .join("rect")
          .attr("x", 0)
          .attr("y", (d, i) => i * 22)
          .attr("width", 16)
          .attr("height", 16)
          .attr("fill", d => colorScale(d));

        legend.selectAll("text")
          .data(categories)
          .join("text")
          .attr("x", 22)
          .attr("y", (d, i) => i * 22 + 12)
          .text(d => labels[d])
          .attr("font-size", "13px");
      });
    }

    function drawScene2() {
      clearScene();

      d3.select("#scene")
        .append("h2")
        .text("Scene 2: Storage Capacity by Data Category");

      d3.select("#scene")
        .append("p")
        .html(`
          To investigate whether reservoir importance is associated with data availability, 
          we analyzed the distribution of storage capacity across three reservoir categories:<br><br>

          <ul>
            <li><strong>Res-R (Data-Rich):</strong> More than 5 years of data</li>
            <li><strong>Res-L (Data-Limited):</strong> 1–5 years of data</li>
            <li><strong>Res-M (Data-Missing):</strong> Less than 1 year of data</li>
          </ul>

          <strong>Figure 2b</strong> presents a boxplot comparison of storage capacities (log scale). 
          The results reveal a clear trend:
          <ul>
            <li><strong>Res-Rs</strong> have the highest average and median storage capacity</li>
            <li><strong>Res-Ls</strong> rank second</li>
            <li><strong>Res-Ms</strong> have the lowest storage capacities, often small local impoundments</li>
          </ul>

          This pattern indicates that <strong>reservoirs with greater hydrological and operational significance tend to have more complete data records</strong> — a likely outcome of stronger management, monitoring, or institutional oversight.
        `);

      const width = 600;
      const height = 500;
      const margin = { top: 30, right: 30, bottom: 40, left: 80 };

      const svg = d3.select("#scene")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      const chart = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

      d3.csv("reservoir_metadata.csv").then(data => {
        const categories = ["Res_R", "Res_L", "Res_M"];
        const colorScale = d3.scaleOrdinal()
          .domain(categories)
          .range(["#1f77b4", "#ff7f0e", "#999999"]);

        const grouped = categories.map(cat => {
          const values = data
            .filter(d => d.CATEGORY === cat && +d.STORAGE_CAP > 0)
            .map(d => +d.STORAGE_CAP)
            .sort(d3.ascending);

          if (values.length === 0) return null;

          const q1 = d3.quantile(values, 0.25);
          const median = d3.quantile(values, 0.5);
          const q3 = d3.quantile(values, 0.75);
          const iqr = q3 - q1;
          const min = d3.min(values.filter(v => v >= q1 - 1.5 * iqr));
          const max = d3.max(values.filter(v => v <= q3 + 1.5 * iqr));

          return { cat, values, q1, median, q3, min, max };
        }).filter(d => d); 

        const y = d3.scaleLog()
          .domain([5e1, 1e8])
          .range([chartHeight, 0]);

        const x = d3.scalePoint()
          .domain(categories)
          .range([0, chartWidth])
          .padding(0.5);

        chart.append("g")
          .call(d3.axisLeft(y).ticks(6, "~s"));

        chart.append("g")
          .attr("transform", `translate(0, ${chartHeight})`)
          .call(d3.axisBottom(x));

        // Draw each boxplot
        grouped.forEach(d => {
          const center = x(d.cat);
          const boxWidth = 50;

          // Whisker line
          chart.append("line")
            .attr("x1", center)
            .attr("x2", center)
            .attr("y1", y(d.min))
            .attr("y2", y(d.max))
            .attr("stroke", "black");

          // Box
          chart.append("rect")
            .attr("x", center - boxWidth / 2)
            .attr("y", y(d.q3))
            .attr("width", boxWidth)
            .attr("height", y(d.q1) - y(d.q3))
            .attr("stroke", "black")
            .attr("fill", colorScale(d.cat));

          // Median line
          chart.append("line")
            .attr("x1", center - boxWidth / 2)
            .attr("x2", center + boxWidth / 2)
            .attr("y1", y(d.median))
            .attr("y2", y(d.median))
            .attr("stroke", "black")
            .attr("stroke-width", 1.5);

            // Draw outliers
          const iqr = d.q3 - d.q1;
          const lowerFence = d.q1 - 1.5 * iqr;
          const upperFence = d.q3 + 1.5 * iqr;
          const outliers = d.values.filter(v => v < lowerFence || v > upperFence);

          chart.selectAll(`.outlier-${d.cat}`)
            .data(outliers)
            .join("circle")
            .attr("cx", center)
            .attr("cy", y)
            .attr("r", 3)
            .attr("fill", "black")
            .attr("opacity", 0.6);

        });

        svg.append("text")
          .attr("x", width / 2)
          .attr("y", height - 5)
          .attr("text-anchor", "middle")
          .text("Reservoir Category");

        svg.append("text")
          .attr("transform", `translate(20, ${margin.top + chartHeight / 2}) rotate(-90)`)
          .attr("text-anchor", "middle")
          .text("Storage Capacity (Acre-Feet)");
      });
    }

    function drawScene3() {
      clearScene();
      d3.select("#scene")
        .append("h2")
        .text("Scene 3: Reservoir Function and Data Availability");

      d3.select("#scene")
        .append("p")
        .html(`
          We further explored how the <strong>primary function</strong> of a reservoir relates to its data availability category.<br><br>

          <strong>Figure 2c</strong> displays pie charts of the main operational purposes across the three groups:

          <ul>
            <li><strong>Res-R (Data-Rich):</strong> Most reservoirs are used for 
              <em>flood control, irrigation, and hydropower</em> (accounting for 74%)</li>
            <li><strong>Res-L (Data-Limited):</strong> Similar to Res-R, 68% serve 
              <em>flood control, irrigation, or hydropower</em></li>
            <li><strong>Res-M (Data-Missing):</strong> Approximately 73% are used for 
              <em>recreation, water supply, and other localized needs</em></li>
          </ul>

          These results show that <strong>reservoirs serving large-scale, multi-purpose objectives tend to have better data coverage</strong>, while smaller or locally managed systems often lack comprehensive records.
        `);

      const width = 900, height = 400;
      const radius = 100;

      const svg = d3.select("#scene")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const color = d3.scaleOrdinal(d3.schemeCategory10);

      d3.csv("reservoir_metadata.csv").then(data => {
        const categories = ["Res_R", "Res_L", "Res_M"];
        const xOffsets = [150, 400, 650];
        const categoryLabels = {
          "Res_R": "Data-Rich (Res-R)",
          "Res_L": "Data-Limited (Res-L)",
          "Res_M": "Data-Missing (Res-M)"
        };

        categories.forEach((cat, i) => {
          const filtered = data.filter(d => d.CATEGORY === cat && d.MAIN_USE);

          // Count each use
          const useCounts = d3.rollup(
            filtered,
            v => v.length,
            d => d.MAIN_USE
          );

          const pie = d3.pie().value(d => d[1]);
          const arc = d3.arc().innerRadius(0).outerRadius(radius);

          const g = svg.append("g")
            .attr("transform", `translate(${xOffsets[i]}, ${height / 2})`);

          const arcs = g.selectAll("path")
            .data(pie([...useCounts]))
            .join("path")
            .attr("d", arc)
            .attr("fill", d => color(d.data[0]))
            .attr("stroke", "white")
            .style("stroke-width", "1px")
            .append("title")
            .text(d => `${d.data[0]}: ${d.data[1]}`);

          // Add percentage labels to each slice
          g.selectAll("text")
            .data(pie([...useCounts]))
            .join("text")
            .attr("transform", d => `translate(${arc.centroid(d)})`)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("fill", "white")
            .text(d => {
              const percent = d.data[1] / d3.sum([...useCounts].map(x => x[1])) * 100;
              return percent >= 5 ? `${percent.toFixed(1)}%` : "";  
            });

          // Add category title
          svg.append("text")
            .attr("x", xOffsets[i])
            .attr("y", 30)
            .attr("text-anchor", "middle")
            .attr("font-weight", "bold")
            .text(categoryLabels[cat]);
        });

        // Optional: Add legend
        const legend = svg.append("g")
          .attr("transform", `translate(${width - 110}, ${height - 270})`);


        const uses = Array.from(new Set(data.map(d => d.MAIN_USE).filter(Boolean))).sort();

        legend.selectAll("rect")
          .data(uses)
          .join("rect")
          .attr("x", 0)
          .attr("y", (d, i) => i * 20)
          .attr("width", 14)
          .attr("height", 14)
          .attr("fill", d => color(d));

        legend.selectAll("text")
          .data(uses)
          .join("text")
          .attr("x", 20)
          .attr("y", (d, i) => i * 20 + 12)
          .text(d => d)
          .attr("font-size", "12px");
      });
    }


    function drawScene4() {
      clearScene();

      d3.select("#scene")
        .append("h2")
        .text("Scene 4: Explore Reservoir Details");

      d3.select("#scene")
        .append("p")
        .html(`
          To encourage further exploration, we provide an interactive map that allows users to examine individual reservoirs.<br><br>

          <strong>Click on any highlighted reservoir</strong> to view:
          <ul>
            <li>Its basic attributes</li>
            <li>A reconstructed example of its operational rule (fake)</li>
          </ul>

          These examples help illustrate how data-driven models — even when applied to reservoirs with incomplete records — 
          can infer plausible operation strategies using information from similar systems.<br><br>

          <em>Note:</em> Rules shown here are representative and may be synthetic.
        `);

      const width = 960;
      const height = 600;

      const svg = d3.select("#scene")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const projection = d3.geoAlbersUsa().scale(1300).translate([width / 2, height / 2]);
      const path = d3.geoPath().projection(projection);

      const tooltip = d3.select("#scene")
        .append("div")
        .attr("class", "tooltip")
        .style("position", "absolute")
        .style("background", "white")
        .style("border", "1px solid #ccc")
        .style("padding", "10px")
        .style("border-radius", "4px")
        .style("box-shadow", "0 0 5px rgba(0,0,0,0.2)")
        .style("display", "none");

      Promise.all([
        d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json"),
        d3.csv("reservoir_metadata.csv")
      ]).then(([us, data]) => {
        // Draw states
        svg.append("g")
          .selectAll("path")
          .data(topojson.feature(us, us.objects.states).features)
          .join("path")
          .attr("fill", "#f0f0f0")
          .attr("stroke", "#999")
          .attr("d", path);

        // Pick 5 random reservoirs
        const picked = d3.shuffle(data.filter(d => d.LONGITUDE && d.LATITUDE)).slice(0, 100);

        // Dummy operation rules
        const dummyRules = [
          "Release = min(Inflow, Target)",
          "Release based on seasonal storage curve",
          "Rule curve with emergency flood control",
          "Irrigation priority: May–Sep",
          "Hydropower optimized by inflow forecast"
        ];

        // Attach a random rule to each picked reservoir
        picked.forEach(d => {
          const randIndex = Math.floor(Math.random() * dummyRules.length);
          d.rule = dummyRules[randIndex];
        });

        const colorScale = d3.scaleOrdinal()
          .domain(["Res_R", "Res_L", "Res_M"])
          .range(["#1f77b4", "#ff7f0e", "#999999"]);

        // Add transparent rect for click-to-hide tooltip
        svg.append("rect")
          .attr("width", width)
          .attr("height", height)
          .attr("fill", "transparent")
          .lower()
          .on("click", () => {
            tooltip.style("display", "none");
          });

        svg.append("g")
          .selectAll("circle")
          .data(picked)
          .join("circle")
          .attr("cx", d => projection([+d.LONGITUDE, +d.LATITUDE])[0])
          .attr("cy", d => projection([+d.LONGITUDE, +d.LATITUDE])[1])
          .attr("r", 6)
          .attr("fill", d => colorScale(d.CATEGORY))
          .attr("stroke", "#333")
          .attr("stroke-width", 1.2)
          .style("cursor", "pointer")
          .on("click", function (event, d) {
            tooltip
              .html(`<strong>${d.RES_NAME || d.DAM_NAME || "Unnamed Reservoir"}</strong><br/>
                    <em>Category: ${d.CATEGORY}</em><br/>
                    <strong>Rule:</strong> ${d.rule}`)
              .style("left", `${event.pageX + 15}px`)
              .style("top", `${event.pageY - 20}px`)
              .style("display", "block");
          });
      });
    }

    // Scene switching
    d3.select("#nextButton").on("click", function () {
      sceneIndex = (sceneIndex + 1) % scenes.length;
      scenes[sceneIndex]();
    });

    // Initialize
    scenes[0]();

  </script>
</body>
</html>
